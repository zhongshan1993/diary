# 冒泡排序 #

已知一组无序数据a[1]、a[2]、……a[n]，需将其按升序排列。首先比较a[1]与a[2]的值，若a[1]大于a[2]则交换两者的值，否则不变。再比较a[2]与a[3]的值，若a[2]大于a[3]则交换两者的值，否则不变。再比较a[3]与a[4]，以此类推，最后比较a[n-1]与a[n]的值。这样处理一轮后，a[n]的值一定是这组数据中最大的。再对a[1]~a[n-1]以相同方法处理一轮，则a[n-1]的值一定是a[1]~a[n-1]中最大的。再对a[1]~a[n-2]以相同方法处理一轮，以此类推。共处理n-1轮后a[1]、a[2]、……a[n]就以升序排列了。降序排列与升序排列相类似，若a[1]小于a[2]则交换两者的值，否则不变，后面以此类推。 总的来讲，每一轮排序后最大（或最小）的数将移动到数据序列的最后，理论上总共要进行n(n-1）/2次交换。
这里采用的是为整型数组添加扩展方法实现的冒泡排序。

优点：稳定

缺点：慢，每次只移动相邻的两个元素。

时间复杂度：理想情况下（数组本来就是有序的），此时最好的时间复杂度为o(N),最坏的时间复杂度(数据反序的)，此时的时间复杂度为o(N^2) 。冒泡排序的平均时间复杂度为o(N^2)。
、
Java程序实现：

	public static void BubbleSort(this int[] arry)
    	{
        	for (int i = 0; i < arry.Length-1; i++)
        	{
            		for (int j = 0; j < arry.Length - 1 - i; j++)
            		{
                		//比较相邻的两个元素，如果前面的比后面的大，则交换位置
                		if (arry[j] > arry[j + 1])
                		{
                   			 int temp = arry[j + 1];
                    			 arry[j + 1] = arry[j];
                    			 arry[j] = temp;
                		}
            		}
        	}
   	 }
